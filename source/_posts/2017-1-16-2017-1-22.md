---
title: 2017/1/16 - 2017/1/22
date: 2017-01-16 15:43:31
categories: Daily
excerpt: 2017年1月9号到15号遇到问题总结
cover: http://oameisqha.bkt.clouddn.com/angular-back.png
---

[toc]

项目主体框架是 `react + redux`

## 扫码登录

### 原理

扫码登录已经是一个很常用的功能了。最开始由于 微信的网页版扫码登录，给用户带来了很大的方便。现在很多网站都已经支持扫码登录。

<p><img src="http://oameisqha.bkt.clouddn.com/14846419006768.jpg" alt="wechat-login" data-action="zoom"></p>

正如一文 [扫码登录是如何实现的？](http://www.jianshu.com/p/7f072ac61763) 所讲的那样：

1. 首先和服务端建立`stomp`[^first]连接
2. 获取到一个全局的唯一ID，根据该ID，计算出特定URL，通过Canvas渲染出二维码
3. 等待用户扫描二维码，期间如果二维码过期，服务端会通过`stomp`进行告知
4. 用户通过移动端app进行扫码(移动端请求特定地址，携带用户id，AccessToken和唯一ID)
5. 服务端进行用户身份校验，然后将用户和全局唯一ID进行绑定，然后通过`stomp`传给浏览器用户id和AccessToken等必要信息
6. 浏览器获取到这些信息之后存储在Cookie中，然后页面进行跳转

[^first]: stomp: 是 Simple(Streaming) Text Oriented Message Protocal 简称，其允许STOMP客户端与任意STOMP消息代理(Broker)进行消息交互。STOMP协议的前身是TTMP协议，转为消息中间件设计。


### 实现

笔者并不会后台开发，对具体实现并不是很了解。但是让消息中间件实现支持`stomp`，要么是已经实现，要么是需要添加一个插件。`stomp`服务器搭建应该很简单，难在业务逻辑上。

这里笔者主要讲解我们在扫码登陆上的一些实现代码。

这里寄托于一个开源库 [stompjs](https://www.npmjs.com/package/stompjs) 通过使用该库，我们就可以很简单的和`stomp`服务器进行连接。

`stompjs`提供3中建立连接书写方式

```javascript
import Stomp from 'stompjs'

// 通过tcp
Stomp.overTCP('localhost', 61613)

// 通过websocket
Stomp.overWS('ws://localhost:61614')

// 通过socket (WebSocket是socket的一种)
Stomp.over(socket)
```

在与服务端建立连接的时候，我们还依赖于一个开源库 [socket-client](https://www.npmjs.com/package/sockjs-client) , 其用来方便建立socket连接。首先使用`WebSocket`，如果失败，它将使用各种浏览器特定的传输协议，你在使用上完全就像使用`WebSocket`一样。

```javascript
// App.js
class App extends Component {
  componentDidMount() {
    // 和服务端建立连接
    this.props.dispatch(connectSocket())
  }
  render() {

    return (
      <div className="app">
        {this.props.children}
      </div>
    )
  }
}
const mapDispatchToProps = (dispatch) => {
  return {
    dispatch,
  }
}
```

`Component App`是整个应用的最顶层，所以只要进入页面，不论是不是登录页，和服务端都会建立连接。然后会得到服务端反馈(用户登录过期，还没有登录过等等)信息。

```javascript
// 建立连接
export const socketConnect = () => {
  const sock = new SockJS(LOGIN_WEBSOCKET)
  const stomp = StompJS.over(sock)

  return stomp
}

export const connectSocket = () => {
  return (dispatch) => {
    const socket = socketConnect()
    // 决定 登录页 样式展示
    dispatch({
      type: SOCKET_OPEN,
      payload: {
        socket,
      },
    })
    // 决定 登录页 样式展示
    return socket.connect({}, () => {
      dispatch({
        type: SOCKET_SUCCESS,
        payload: {
          socket,
        },
      })
      // 监听广播消息
      return socket.subscribe(LOGIN_BROAD_CAST, (message) => {
        const body = JSON.parse(message.body)

        console.log(body)

        // 判断 全局唯一id 是否一致
        if (body.deviceId === auth.getDevice()) {
          // 用户登录成功
          if (body.status === 1) {
            auth.setToken(body.token, body.userId, body.deviceId)
            dispatch(updateAppLoginState(body.userId, true))
            // 跳转至主页
            hashHistory.push('/main')
          }

          // 登录过期
          if (body.status === -1) {
            auth.logout()
            dispatch(updateAppLoginState('', false))
            // 跳转至登录页
            hashHistory.push('/login')
          }
        }
        // 接受消息
        dispatch({
          type: SOCKET_MESSAGE,
          payload: {
            message: body,
            socket,
          },
        })
      })
    }, (error) => {
      // 决定 登录页 样式展示
      dispatch({
          type: SOCKET_CLOSE,
          error,
      })
    })
  }
}
```

难点在这儿，其他和上面讲解步骤一样。

我们通过特定接口获取到全局id，然后通过Canvas渲染出二维码，等待用户扫码。

扫码之后，服务端会通过广播地址，带上id发送消息。我们只要判断自己手上的id和广播消息具有id是否一致，如果一致就说明用户已经扫码登录成功


## Excel 导出


