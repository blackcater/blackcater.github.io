---
title: 2017/1/9 - 2017/1/15
date: 2017-01-09 21:41:16
categories: Daily
excerpt: 2017年1月9号到15号遇到问题总结
cover: /img/banner-4.png
---

[toc]

## 1月9日

### 音频和视频播放器

今天主要工作是封装一个 视频播放器 和 音频播放器。开发框架为`react`。这两个组件 现在是用于 公司的一个 文章编辑器中，用于视频和音频的预览。

正如大家可以想象的：

- 视频播放器：暂停/播放，进度条，进度调节，音量调节，全屏播放
- 音频播放器：暂停/播放，进度条，进度调节，音量调节

猛然一看是不是一样的？其实，就是一样的。也就样式不一样。大部分代码都一样。

#### 暂停/播放

这个很简单，通过组件内的一个状态进行控制。

#### 进度条

进度条，如果需要支持 滑动调节，那么你需要监听 `mousedown`，`mousemove`, `mouseup`。 

移动`div`的思想就是可以用到这了。

#### 音量调节

和进度条调节一样

#### 全屏播放

这个确实是坑了自己很久。因为原来从没有做过。

由于是自定义的视频播放器，`video`放在最外层的`div`里

```html
    <div ref="palyer">
        <video src={src} controls={false}>Your browser can't support play this video. Please use more advanced browser!</video>
    </div>
```

全屏的时候，是给`this.refs.palyer`进行全屏。 幸运的是，浏览器是支持的。

```js
    // Supports most browsers and their versions.
    var requestMethod = element.requestFullScreen ||
                        element.webkitRequestFullScreen ||
                        element.mozRequestFullScreen ||
                        element.msRequestFullScreen

    if (requestMethod) {
        // Native full screen.
        requestMethod.call(element)
    } else if (typeof window.ActiveXObject !== "undefined") {
        // Older IE.
        var wscript = new ActiveXObject("WScript.Shell")
        if (wscript !== null) {
            wscript.SendKeys("{F11}")
        }
    }
```

有进入全屏，就有退出的方法

```javascript
    var cancelMethod = document.exitFullscreen ||
                       document.msExitFullscreen ||
                       document.mozCancelFullScreen ||
                       document.oCancelFullScreen ||
                       document.webkitExitFullscreen

    if (cancelMethod) {
        cancelMethod()
    }
```

当进入全屏状态之后，大部分浏览器都会提示说：`按ESC可推出全屏`。当用户按`esc`键的时候，我们需要修改组件内的`state`，以确保呈现的样式是对的。

所以，我们需要要对全屏变化操作进行监听。

```javascript
  componentDidMount() {
    addEvent(document, 'fullscreenchange', this.escKeyHandler) // standard
    addEvent(document, 'mozfullscreenchange', this.escKeyHandler) // mozilia
    addEvent(document, 'webkitfullscreenchange', this.escKeyHandler) // webkit Safari Chrome
    addEvent(document, 'msfullscreenchange', this.escKeyHandler) // microsoft IE
  }

  componentWillUnmount() {
    removeEvent(document, 'fullscreenchange', this.escKeyHandler)
    removeEvent(document, 'mozfullscreenchange', this.escKeyHandler)
    removeEvent(document, 'webkitfullscreenchange', this.escKeyHandler)
    removeEvent(document, 'msfullscreenchange', this.escKeyHandler)
  }
```

### 图片/音频/视频上传

这个没难度。在使用`draft-js`(以后会抽时间写一个教程)进行该功能开发的时候，遇到了一个有点头疼的问题。

就是 需要 清除 `input` 元素原来的数据。其实很简单：`$input.value = ''`

成果：

<p><img src="http://oameisqha.bkt.clouddn.com/14839728349004.jpg" alt="video-player" data-action="zoom" /></p>

<p><img src="http://oameisqha.bkt.clouddn.com/14839728570084.jpg" alt="audio-player" data-action="zoom" /></p>


## 1月10日 - 1月11日

这两天 在为 富文本 添加 文件上传功能。

为了别处也能 使用文件上传，所以封装文件上传功能思考了很久。

### 七牛文件上传

七牛文件上传基本思路是：

**Front**[^first]先向**Back**[^second]发送一个请求，获取上传的`token`。有了这个`token`，我们才能将文件上传到七牛上。

[^first]: **Front** - 前端，指浏览器，移动客户端等
[^second]: **Back** - 后端，指服务端

之后，就是将文件上传到七牛。

### axios

数据请求，我们使用的是现在很火的 [axios](https://github.com/mzabriskie/axios)

文件上传代码大致如下

```javascript
    import axios, { CancelToken } from 'axios'

    export const uploadFilesToQiniu = (files, /* other props */) => {
        // deal with default params
        // check params

        // request for token
        const source = CancelToken.source()
        axios.post('/api/qiniu/token', [/* multiple request data */], {
            cancelToken: source.token,
        })
            .then(result => {
                const data = result.data.res

                const reqData = {
                    key: data.filePath,
                    token: data.fileToken,
                    file: files[i],
                    domain: 'a'
                }
                const formData = new FormData()

                for (const key in reqData) {
                    formData.append(key, reqData[key])
                }

                // upload file
                const source = CancelToken.source()
                axios.post('https://up.qbox.me', formData, {
                        onUploadProgress(progressEvent) {
                            // progress callback
                            progressCb && progressCb(progressEvent)
                        },
                        cancelToken: source.token,
                      })
                      .then(res => (cb && cb(res.data.res))) // success callback
                      .catch(err => (errCb && errCb(err))) // err callback

                uploadCb && uploadCb(source)
            })
            .catch(err => (errCb && errCb())) // error callback
        
        // after sending token request.
        tokenCb && tokenCb(source)
    }
```

我们先请求获取 `token`，之后在根据 `token` 构造文件上传请求。请求中，提供了许多回调函数。例如：成功时的`cb`，出错时的`errCb`，文件上传时的`progressCb`等等。

这里有部分代码看起来很怪异

```javascript
    import axios, { CancelToken } from 'axios'
    
    const source = CancelToken.source()

    axios.post('/api/qiniu/token', [/* multiple request data */], {
        cancelToken: source.token,
    })

    // source.cancel() 中断请求
```

这部分代码是让 `axios`可以支持 中断请求。 只要我们传出`source`对象，就可以调用`source.cancel()`来中断请求。

官方在中断请求，还有一种写法

```javascript
    import axios from 'axios'

    const key = generateUniqueKey()

    axios.post(url, {
        requestId: key,
    })

    // 中断请求
    axios.abort(key)
```

`axios`必须在`options`中传入`requestId`。在之后，通过该值，中断对应请求。 本人试过这种方式，不过 报错说，`abort`方法找不到。我也给`axios`提了一个issue，问了一下。不过还没回复我。

其中有两个回调`tokenCb`和`uploadCb`就是将`souce`对象传出去，用于中途取消请求。


## 1月12日

### 上传进度条
 
今天在做一些体验上的优化：给文件上传添加进度条

样式基本是这样:

<p><img src="http://oameisqha.bkt.clouddn.com/QQ20170114-0.png" alt="file-upload-progress" data-action="zoom" /></p>

开发框架使用的是`react`技术栈，使用`redux`进行状态管理。编辑器使用的是`draft-js`框架(后面会出一些教程，介绍这个框架)。

#### `redux`工具函数

使用过`redux`的同学，可能都知道几个`redux`核心的概念：`action`, `reducer`。对于大型项目，有很多`action`，那么就会写很多个函数用于创建`action`。也需要写很多`switch... case...`语句创建`reducer`。这无疑是一个噩梦。

不过有一个开源项目[redux-actions](https://www.npmjs.com/package/redux-actions)可以用于方便框架`action`和`reducer`。我写了一个简单的工具函数，用于创建`action`和`reducer`。

```javascript

/**
 * 快速 创建 action
 *
 *    例如：const someActionCreator = createAction('SOME_ACTION')
 *      -> someActionCreator('res')
 *      -> { type: 'SOME_ACTION', payload: 'res', error: false }
 *
 * @param type
 * @param param
 */
export const createAction = (type, param = null) => {
  return (...args) => {
    let payload = null
      , error = false

    if (param === null) {
      if (args.length === 1) {
        payload = args[0]
        error = (args[0] instanceof Error)
      } else if (args.length > 1) {
        payload = args
      }
    } else if (typeof param === 'function') {
      try {
        const res = param.apply(this, args)

        payload = res
        error = (res instanceof Error)
      } catch (err) {
        payload = err
        error = true
      }
    }

    return {
      type,
      payload,
      error,
    }
  }
}


/**
 * 快速创建多个action
 *
 * @param paramsObj
 */
export const createActions = paramsObj => {
  const res = {}

  for (const key in paramsObj) {
    res[key] = createAction(key, paramsObj[key])
  }

  return res
}

```

```javascript

/**
 * 快速创建 reducer
 */
export const createReducer = (paramsObj, initialState = {}) => {
  /**
   * 返回reducer
   */
  return (state = initialState, action) => {
    if (action.type in paramsObj) {
      return paramsObj[action.type].call(this, state, action.payload, action.error)
    }

    return state
  }
}

```


#### 进度条实现

我们以图片上传为例(视频和音频上传相似)。

`component`大致代码如下：

```javascript

import React, { Component, PropTypes } from 'react'
import ReactDOM from 'react-dom'

class AtomicPhoto extends Component {

  constructor(props) {
    super(props)

    this.state = {
      timer: null,
    }

    this.imageLoadHandler = this.imageLoadHandler.bind(this)
  }
  imageLoadHandler(e) {
    const $img = e.target
    const $container = ReactDOM.findDOMNode(this.refs.container)
    const { width: imgWidth, height: imgHeight } = $img
    const { clientWidth: cWidth, clientHeight: cHeight } = $container

    if (imgHeight > 348) {
      $img.style.height = '348px'

      if ((imgWidth / imgHeight) > (cWidth / cHeight)) {
        const rWidth = (imgWidth / imgHeight) * cHeight

        $img.style.left = `${(rWidth - cWidth) / 2}px`
      }
    }
  }
  render() {
    const { src, name, uploadStatus, progress } = this.props

    return (
      <div className="atomic-photo" ref="container">
        <img src={src} alt={name} onLoad={this.imageLoadHandler}/>
        <span className="delete" onClick={this.deleteHandler}>
          <svg width="16px" height="16px" viewBox="0 0 16 16">
              <g id="Page-1" stroke="none" strokeWidth="1" fill="none" fillRule="evenodd">
                  <g id="发布帖子插入了图片" transform="translate(-1054.000000, -739.000000)" fill="#FFFFFF">
                      <g id="30X30删除" transform="translate(1054.000000, 739.000000)">
                          <g id="图层_1">
                              <g id="XMLID_1_">
                                  <path d="M15.3,2.1 L0.7,2.1 C0.4,2.1 0.1,2.4 0.1,2.7 C0.1,3 0.4,3.3 0.7,3.3 L15.2,3.3 C15.5,3.3 15.8,3 15.8,2.7 C15.8,2.4 15.6,2.1 15.3,2.1 L15.3,2.1 Z" id="XMLID_7_"></path>
                                  <path d="M13.5,4 C13.2,4 12.9,4.2 12.8,4.6 L12.2,14.3 L10.3,14.3 L10.3,5.6 C10.3,5.3 10,5 9.7,5 C9.4,5 9.1,5.3 9.1,5.6 L9.1,14.3 L7,14.3 L7,5.6 C7,5.3 6.7,5 6.4,5 C6.1,5 5.8,5.3 5.8,5.6 L5.8,14.3 L3.8,14.3 L3.2,4.6 C3.2,4.3 2.9,4 2.5,4 C2.2,4 1.9,4.3 1.9,4.7 L2.5,15 C2.5,15.3 2.8,15.6 3.1,15.6 L12.8,15.6 C13.1,15.6 13.4,15.3 13.4,15 L14,4.7 C14.1,4.3 13.8,4 13.5,4 L13.5,4 Z" id="XMLID_8_"></path>
                                  <path d="M6.5,1.7 L9.4,1.7 C9.7,1.7 10,1.4 10,1.1 C10,0.8 9.7,0.5 9.4,0.5 L6.5,0.5 C6.2,0.5 5.9,0.8 5.9,1.1 C5.9,1.4 6.2,1.7 6.5,1.7 L6.5,1.7 Z" id="XMLID_9_"></path>
                              </g>
                          </g>
                      </g>
                  </g>
              </g>
          </svg>
        </span>
        { uploadStatus === 'finished' ? null : (
            <div className="mask">
              <div className={`progress ${uploadStatus === 'error' ? 'error' : ''}`}>
                <div className="inner" style={{
                  width: `${progress}%`,
                }}></div>
              </div>
            </div>
        ) }
      </div>
    )
  }
}

AtomicPhoto.propTypes = {
  src: PropTypes.string.isRequired, // 图片 的 src值
}

AtomicPhoto.defaultProps = {}

```

在实现功能之前，我们先得理清楚，哪些数据需要存到`store`里面，数据如何流动。然后再去写代码。

在这个需求中，我们需要的是：

1. 当前的文件上传状态：如果失败需要显示失败的样式，如果成功需要取消`mask`

2. 当前上传进度：动态显示进度条的长度。

3. 请求对象：`token`请求或者文件上传请求时，需要同步`source`对象，用于取消上传请求。

文件上传有几个状态：开始前，正在上传，上传失败，上传完成。我们用上一节说的`redux`工具函数进行`action`和`reducer`创建。

```javascript
// action.js
export const POST_FILE_UPLOAD_LOADING = 'USER/POST_EDIT/POST_FILE_UPLOAD_LOADING'
export const POST_FILE_UPLOAD_ERROR = 'USER/POST_EDIT/POST_FILE_UPLOAD_ERROR'
export const POST_FILE_UPLOAD_FINISHED = 'USER/POST_EDIT/POST_FILE_UPLOAD_FINISHED'
export const POST_FILE_UPLOAD_REQUEST = 'USER/POST_EDIT/POST_FILE_UPLOAD_REQUEST'

const {
  [POST_FILE_UPLOAD_START]: fileUploadStart,
  [POST_FILE_UPLOAD_LOADING]: fileUploadLoading,
  [POST_FILE_UPLOAD_ERROR]: fileUploadError,
  [POST_FILE_UPLOAD_FINISHED]: fileUploadFinished,
  [POST_FILE_UPLOAD_REQUEST]: setFileUploadRequest,
} = createActions({
  // 开始上传前
  [POST_FILE_UPLOAD_START](entity) {
    return { entity }
  },
  // 正在上传
  [POST_FILE_UPLOAD_LOADING](entity, progress) {
    return { entity, progress }
  },
  // 上传失败
  [POST_FILE_UPLOAD_ERROR](entity) {
    return { entity }
  },
  // 上传完成
  [POST_FILE_UPLOAD_FINISHED](entity) {
    return { entity }
  },
  // source 同步
  [POST_FILE_UPLOAD_REQUEST](entity, source) {
    return { entity, source }
  },
})
```

```javascript
// reducer.js
import update from 'immutability-helper'
import {
  POST_FILE_UPLOAD_START,
  POST_FILE_UPLOAD_LOADING,
  POST_FILE_UPLOAD_ERROR,
  POST_FILE_UPLOAD_FINISHED,
  POST_FILE_UPLOAD_REQUEST,
} from 'actions/user/postEdit'

const initialState = {
  loading: {},
  request: {},
}

/* eslint-disable no-unused-vars */
export default createReducer({
  [POST_FILE_UPLOAD_START](state, { entity }) {
    return update(state, {
      loading: {
        [entity]: {
          $set: {
            uploadStatus: 'start',
            progress: 0,
          },
        },
      },
    })
  },
  [POST_FILE_UPLOAD_LOADING](state, { entity, progress }) {
    return update(state, {
      loading: {
        [entity]: {
          $set: {
            uploadStatus: 'loading',
            progress: progress,
          },
        },
      },
    })
  },
  [POST_FILE_UPLOAD_ERROR](state, { entity }) {
    return update(state, {
      loading: {
        [entity]: {
          $set: {
            uploadStatus: 'error',
            progress: 100,
          },
        },
      },
    })
  },
  [POST_FILE_UPLOAD_FINISHED](state, { entity }) {
    return update(state, {
      loading: {
        [entity]: {
          $set: {
            uploadStatus: 'finished',
            progress: 100,
          },
        },
      },
    })
  },
  [POST_FILE_UPLOAD_REQUEST](state, { entity, source }) {
    return update(state, {
      request: {
        [entity]: {
          $set: source,
        },
      },
    })
  },
}, initialState)
```

这里有一个`update`函数，来自于[immutability-helper](https://npmjs.org/package/immutability-helper)。其作用就是用于替代 [immutable](https://www.npmjs.com/package/immutable)。

上面实现中，有一个`entity`参数，其来源里`draft-js`框架中`Entity`创建得到的一个`key`。在功能实现中，每次上传文件，都会产生一个`Entity`实例，每个实例的`key`都不同，且不会重复。

`draft-js`会将这个`key`传给组件`AtomicPhoto`，所以，我们就可以从`store`中的`loading`中通过`redux`获取到 上传状态数据 和 上传进度。从`request`中获取`source`对象，用于取消请求。

现在我们修改一下`AtomicPhoto`代码

```javascript
import { connect } from 'react-redux'

const mapStateToProps = (state, props) => {
  const { entity } = props

  return { ...state.user.postEdit.loading[entity], source: state.user.postEdit.request[entity] }
}

const mapDispatchToProps = (dispatch) => ({ dispatch })

export default connect(mapStateToProps, mapDispatchToProps)(AtomicPhoto)

```

## 1月13日

### 文件拖拽上传和文件复制粘贴上传

这里 这两个功能都比较好实现，都是在`draft-js`框架之上，调用文件上传功能即可。

`draft-js`提供两个`props`: ==handleDroppedFiles==和==handlePastedFiles==

这两个`props`都是函数，其中有个参数是`File`对象。然后我们调用前面实现的文件上传工具类，就可以实现该方法了。

在`handlePastedFiles`实现文件复制粘贴上传时，图片文件是可以的，视频音频文件是不行的。参数是一个`Blob`对象。


## 总结

这一周，具有挑战的可能就是 播放器功能实现 和 文件上传进度条 实现。

这里讲解的是大概的实现思路，但嵌入到`draft-js`框架中，可能就复杂一点了。

`draft-js`已经是第二次使用了，第一次在什么都不懂的情况下去实现一个`富文本编辑器`。但通过那一次的经验积累，这一次实现就简单很多。很多地方都进行了优化。

最后，推荐一本书，最近正在阅读：`人类简史`(尤瓦尔·赫拉利) 其第二本书 `未来简史` 也快发售了。看了一些，蛮不错的。 
