+++
title = "图解内存管理(译)"
description = ""
tags = ["图解", "内存管理"]
categories = ["译文"]
date = "2017-07-03T22:12:17+08:00"
+++


## 简介

为了理解为何`ArrayBuffer`和`SharedArrayBuffer`被加入到JavaScript中，你需要首先对内存管理有一些了解。

你可以把机器中的**内存**想象成是由一堆盒子组合而成的，我认为有点像你工作中使用的邮筒，或者说像学龄前儿童存放物品的小房间。

如果你需要为一个小孩放东西，那么你可以将东西放到盒子里。

![1-1](/images/1/1-1.png)

这些盒子都有自己的号码，这就是**内存地址(Memory Address)**。就是你如何告诉其他人在哪能找到你为他们所放物品的方法。

每个盒子有同样的尺寸(大小)并且能够存放固定容量的信息。盒子的尺寸是由机器决定的。这里尺寸就是**字节大小(word size)**。通常情况下是32-bits或64-bits。为何使展现更为简单，我们将使用8-bits字节大小。

![1-2](/images/1/1-2.png)

如果我们想在一个盒子里放入数字2，这是十分简单的。数字很容易用[二进制的形式进行展现](https://www.khanacademy.org/math/algebra-home/alg-intro-to-algebra/algebra-alternate-number-bases/v/decimal-to-binary)。

![1-3](/images/1/1-3.png)

要是我们想要存储非数字类型能？像字符`H`？

我们需要有一种像展示数字一样的方式。为了实现这种方式，我们需要一种编码方式，例如[UTF-8](https://en.wikipedia.org/wiki/UTF-8)。并且我们需要一些东西来将他们转化为一个数字...就像编码环一样。然后我们就可以存储他们了。

![1-4](/images/1/1-4.png)

当我们想从盒子中取出的时候，我们需要将其通过一个解码装置转化回为`H`。


## 自动内存管理

当你使用`JavaScript`的时候，你根本不需要考虑内存方面。它被抽象的原理你的感知。这就意味着你不能直接的操作内存。

这是因为，JS引擎扮演者中间者的角色。它为你管理着内存。

![1-5](/images/1/1-5.png)

所以，让我们看一些JS代码示例，例如像`React`，想创建一个变量。

![1-6](/images/1/1-6.png)

JS引擎所做的就是将值通过编码器用二进制进行表示。

![1-7](/images/1/1-7.png)

并且，JS引擎会在内存中找能能存储二进制的空间。这个过程称作**内存分配(Allocate Memory)**。

![1-8](/images/1/1-8.png)

然后，JS引擎将会保持追踪是否该变量仍然需要在程序中被访问。如果变量不在能够被访问，该内存将会被回收再利用以备JS引擎能存放新值。

![1-9](/images/1/1-9.png)

监听变量(字符串，对象，和内存中其他类型的值)的过程和变量不再可访问儿被回收的过程叫做**垃圾回收(Garbage Collection)**。

像`JavaScript`这种语言，其代码将不会直接操作内存，这种语言被称为**内存管理语言(Memory-managed Languages)**。

自动内存管理可以使开发人员更轻松。但是也造成了一些麻烦，并且这些麻烦有时候造成了不可预知的性能问题。


## 手动内存管理

有手动内存管理的语言是不一样的。例如，我们看看`React`使用`C`语言写的时候如何使用内存(现如今使用[WebAssembly](https://hacks.mozilla.org/2017/02/a-cartoon-intro-to-webassembly/)使得这成为[可能](https://www.youtube.com/watch?v=3GHJ4cbxsVQ))。

`C`语言没有想`JavaScript`那样的内存上的抽象层。相反地，你可以直接操作内存。你可能从内存中取出东西，并且你也能将东西存储内存。

![1-10](/images/1/1-10.png)

当你将`C`语言或者其他语言编译为`WebAssembly`，你使用的工具将向你的`WebAssembly`里添加一些有帮助的代码。例如，将会添加用于编码和解码字节的代码。这种代码将会在运行环境中被调用。运行环境将处理JS引擎为JS做的一些事情。

![1-11](/images/1/1-11.png)

但是对于手动管理语言，该运行时不包括垃圾回收。

这并不意味着你完全就得靠自己。甚至一些手动内存管理语言，你讲可以从语言运行时钟得到一些帮助。例如，在`C`语言中，运行时将跟踪哪些内存地址是开放的，这被称为**可利用空间表(Free List)**。

![1-12](/images/1/1-12.png)

你能够使用函数`malloc`(内存分配的短语)来要求运行时去寻找一些可以用来存放数据的内存。这将使得这些地址从可利用空间表中被移除。当你使用完这些数据，你必须调用`free`函数去释放内存。然后这些地址将被加回到可利用空间表中。

你必须明确何时去调用这些函数。这就是为何叫做手动内存管理了——你需要亲手管理内存。

作为一个开发者，明确何时去清理不同部分的内存是十分困难的。如果你再错误的时间进行了这些操作，将会造成bug，甚至导致安全漏洞。如果你不去进行这些操作，又将会导致内存泄露。

这就是为何许多的现代语言使用自动内存管理的原因——避免人为犯错。但是这也造成了性能损耗。我将会在[下一篇文章](#)进行讲解。

*原文：[A crash course in memory management](https://hacks.mozilla.org/2017/06/a-crash-course-in-memory-management/)*
